1. (a) 100101 (b) 11011101 (c) 531 (d) 110111.111 

   (e) 010011 (f) 1e.8

2. (a) 00110011 (b) 0000000000011111

3. (a) 1 11111111110 0011100000000000000000000000000000000000000000000000

   (b) 0 10000100 10110000000000000000000

4. (a) (641)~10~ = 0 0110 0100 0001    (-259)~10~ =  1 1101 1010 0111

   (b) (121)~10~ =      0001 0010 0001

   ​     (-178)~10~ =  1 1000 0010 0010  

   ​      结果:        1 1001 0100 0011

5. (a) 1234H

   在内存中的存储方式为：34 12

   (b) A122H

   在内存中的存储方式为：22 A1

6. (a) 约为 $1.8 \times 10^{308}$

   (b) 为$2^{-1074}$

   (c) 为$2^{-1074}$

   (d) 为$2^{971}$

   (e) 为$2046 * 2^{52} + 1$

7. <p align="center">Table 1: 8-bit二进制码</p>

   |                      | 8-bit 带符号原码 | 反码 | 补码 |
   | :------------------: | :--------------: | :--: | :--: |
   |    数值最大的正数    |       127        | 127  | 127  |
   |    数值最大的负数    |       -127       | -127 | -128 |
   | 可表示多少不同的数值 |       256        | 255  | 256  |

8. (a) 页目录项 $2GB \div 4KB \times 4字节 = 2MB ~~~2GB \div 4MB \times 4字节 = 2KB$结果为2MB + 2KB。

   (b) 可以使用转译后援缓冲（Translation Lookaside Buffer，TLB）。TLB是一个硬件设备，它缓存了最近使用的页表项，当进行地址转换时，首先在TLB中查找，如果找到了就直接使用，如果没有找到，才去访问页表。这样可以大大减少页表访问的次数，从而减少时间花费。
   
9. <p align="center">Table 2:寻址模式</p>

|              |                            实模式                            |                           保护模式                           |
| :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   段的大小   | 段的大小是固定的，为64KB。这是因为偏移地址是16位的<br>所以最大的偏移量是2^16-1，即65535字节，也就是64KB | 段的大小是可变的，最大可以达到4GB<br>这是因为在保护模式下，段的大小是由段描述符中的限长字段来定义的，这个字段是20位的，所以理论上最大的段大小是2^20个页，每页4KB，所以最大的段大小是4GB。 |
|  段起始地址  | 在80386的实模式下，段的起始地址是由段寄存器的值乘以16得到的。这是因为在实模式下，内存是分段的，每个段的大小是64KB，段之间的间隔是16字节。 | 段的起始地址是由段描述符中的基地址字段确定的。基地址是一个32位的值，它与段内的偏移量相加，得到了在物理内存中的实际地址。 |
| 段寄存器内容 | 在80386的实模式下，段寄存器（CS、DS、SS、ES、FS、GS）的内容是用来生成物理地址的一部分。每个段寄存器都是16位的，它们的值被用作段基地址的高16位。 | 在80386的保护模式下，段寄存器（CS、DS、SS、ES、FS、GS）的内容不再直接表示段的基地址，而是表示段描述符在全局描述符表（GDT）或局部描述符表（LDT）中的索引。这个索引被称为选择子（Selector）。 |

10. (a) DS=2000H, EAX=00003000H 物理地址 = 2000H * 10H + 3000H = 20000H + 3000H = 23000H

    (b) DS=1A00H, ECX=00002000H 物理地址 = 1A00H * 10H + 2000H = 1A000H + 2000H = 1C000H

    (c) DS=C000H, ESI=0000A000H 物理地址 = C000H * 10H + A000H = C0000H + A000H = CA000H

    (d) SS=8000H, ESP=00009000H 物理地址 = 8000H * 10H + 9000H = 80000H + 9000H = 89000H

    (e) DS=1239H, EDX=0000A900H 物理地址 = 1239H * 10H + A900H = 12390H + A900H = 1D290H

11. DS=0105H，转换为二进制是0000 0001 0000 0101。

    - RPL是01，所以请求的特权级是1。
    - TI是1，所以使用的是GDT。
    - 索引是0000 0001 0000 0，转换为十进制是32。

    所以，DS=0105H将选择LDT中的第32个描述符，请求的特权级是1。

12. (a)

    i.   0x110090
    ii.  0x010000
    iii. 0x112900

    (b) 物理地址:00002001H 字节:

    - 第一个字节：00
    - 第二个字节：00
    - 第三个字节：20
    - 第四个字节：01

    (c) 物理地址:00003004H 字内容:10 03

13. i. MOV AX, BX (a) 寄存器寻址 (b) 数据是BX寄存器的值，即00000004H (c) 数据从BX寄存器移动到AX寄存器

    ii. MOV AL,3AH (a) 立即数寻址 (b) 数据是3AH (c) 数据从立即数3AH移动到AL寄存器

    iii. MOV AX,[1012H] (a) 直接寻址 (b) 数据是内存地址1012H的内容 (c) 数据从内存地址1012H移动到AX寄存器

    iv. MOV CL,[BX] (a) 寄存器间接寻址 (b) 数据是内存地址00000004H的内容 (c) 数据从内存地址00000004H移动到CL寄存器

    v. MOV BP,[BX+SI] (a) 基址加偏移量（变址寻址） (b) 数据是内存地址00000004H + 00000002H = 00000006H的内容(c) 数据从内存地址00000006H移动到BP寄存器

    vi. MOV CL,[BX+4] (a) 基址相对加偏移量 (b) 数据是内存地址00000004H + 4 = 00000008H的内容 (c) 数据从内存地址00000008H移动到CL寄存器

    vii. MOV ARRAY[BX+SI],DX (a) 基址相对加偏移量寻址方式 (b) 被传输的数据是DX寄存器的内容 (c) 数据移动的起始位置是DX寄存器，终止位置是内存的ARRAY[BX+SI]。

14. (a) 3A8CH

    (b) 3A52H

    (c) 0055H

    (d) C574H

    (e) 3A18H

15. ```asm
    ; (a) 将寄存器中最后的四位置为1
    OR AX, 0FH
    
    ; (b) 再将寄存器最高的三位置为0
    AND AX, 1FFFH
    
    ; (c) 将寄存器的第7，8，和9位求反
    XOR AX, 0380H
    ```
