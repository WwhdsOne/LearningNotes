# 简单的线程示例

1. 将执行任务的代码放在一个类的`run`方法中，类要实现`Runnable`接口。`Runnable`内部十分简单，只有一个`run`方法

   ```java
   @FunctionalInterface
   public interface Runnable {
       public abstract void run();
   }
   ```

   `Runnable`是一个函数式接口，所以可以用lambda表达式创建实例

2. 从`Runnable`构造一个`Thread`对象

   ```java
   Thread t = new Thread(r);
   ```

3. 启动线程

   ```java
   t.start();
   ```

组合在一起代码如下：

```java
new Thread(() -> {
    for (int i = 0; i < 100; i++) {
        System.out.println("Hello, World! Two!");
    }
}).start();
new Thread(()->{
    for (int i = 0; i < 100; i++) {
        System.out.println("Hello, World! One!");
    }
}).start();
```

打印内容部分如下：

```text
………
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! One!
Hello, World! One!
Hello, World! One!
Hello, World! One!
………
```

可以看到输出是交错的

# 12.2 线程状态

线程有如下六种状态：

- New(新建)

- Runnable(可运行)

- Blocked(阻塞)

- Waiting(等待)

- Timed waiting(计时等待)

- Terminated(终止)

  可以用`getState`方法确定线程状态

<img src="https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202024-04-01%2012.31.jpg" alt="扫描全能王 2024-04-01 12.31" style="zoom: 25%;" />

# 12.3 线程属性

## 12.3.1 中断线程

当线程内程序执行完成或者出现未捕获的异常时，这个线程将终止。

除了已经废弃的stop方法没有办法使一个线程终止。

不过现在有`interrut`方法可以请求终止一个线程

当使用这个方法后，线程就会被设置为中断状态`interrupted status`。每个线程都有这样一个boolean标准。各个线程都应该不时地检查这个标志

要确定是否终端可以先获取当前线程`Thread.currentThread`然后调用`isInterrupted`方法

```java
public static void main(String[] args) {
    // 创建一个Runnable对象，定义线程要执行的任务
    Runnable r = () -> {
        int i = 233;
        // 循环执行任务
        for ( int j = 0; j < i; j++ ) {
            // 打印当前是第几次循环
            System.out.println("当前是第" + j + "次循环");
            // 当循环到第10次时，中断当前线程
            if(j == 10){
                Thread.currentThread().interrupt();
            }
            // 检查当前线程是否被中断
            if(Thread.currentThread().isInterrupted()){
                // 如果线程被中断，打印一条消息并退出循环
                System.out.println("线程被中断");
                break;
            }
        }
    };
    // 创建一个新的线程
    Thread t = new Thread(r);
    // 启动线程
    t.start();
}
```

运行后打印内容如下

```
当前是第0次循环
当前是第1次循环
当前是第2次循环
当前是第3次循环
当前是第4次循环
当前是第5次循环
当前是第6次循环
当前是第7次循环
当前是第8次循环
当前是第9次循环
当前是第10次循环
线程被中断
```

如果每次执行后调用`sleep()`方法或者其他中断方法,既没有必要也没有用处。此时调用`sleep`方法不会休眠，同时会清除`中断状态`并抛出`InterruptedException`

所以如果使用`sleep`方法应当捕获`InterruptedException`而非检查中断状态

```java
public static void sleep方法和中断状态(){
    // 创建一个Runnable对象，定义线程要执行的任务
    Runnable r = () -> {
        int i = 233;
        try{
            // 循环执行任务
            for ( int j = 0; j < i;  j++ ) {
                // 打印当前是第几次循环
                System.out.println("当前是第" + j + "次循环");
                // 线程暂停300毫秒
                Thread.sleep(300);
                // 当循环到第10次时，中断当前线程
                if(j == 10){
                    Thread.currentThread().interrupt();
                }
            }
        } catch (InterruptedException e) {
            // 如果线程在睡眠状态下被中断，打印线程的中断状态
            System.out.println(Thread.currentThread().isInterrupted());
            // 打印一条消息并退出循环
            System.out.println("线程被中断");
            // 抛出运行时异常
            throw new RuntimeException(e);
        }
    };
    // 创建一个新的线程
    Thread t = new Thread(r);
    // 启动线程
    t.start();
}
```

或者也可以为整个方法抛出异常，这样调用者就知道发生了什么

```java
public static void sleep方法和中断状态() throws InterruptedException {
    int i = 233;
    for ( int j = 0; j < i; j++ ) {
        System.out.println("当前是第" + j + "次循环");
        if ( j == 10 ) {
            Thread.currentThread().interrupt();
        }
        Thread.sleep(300);
    }
}
```

调用它的main方法如下：

```java
public static void main(String[] args) throws InterruptedException {
    Runnable r = () ->{
        try {
            sleep方法和中断状态();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    };
    Thread t = new Thread(r);
    t.start();
}
```



## 12.3.2 守护线程

可以调用`t.setDaemon(true)`。它唯一的作用是给其他线程提供服务，如计时服务等。

清空果实缓存项的线程也是守护线程，只剩下守护线程，虚拟机就会退出。

## 12.3.3 线程名

可以用`t.setName("Wwhds t")`为线程设置名字

## 12.3.4 未捕获异常的处理器

线程的`run`方法不能抛出任何检查型异常，但是非检查型异常可能导致线程终止，这种情况下线程会死亡

在线程死亡前，会传递到一个用于处理未捕获异常的处理器

这个处理器必须属于一个实现了`Thread.UncaughtExceptionHandler`的类

```java
class 处理器 implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("线程" + t.getName() + "抛出了异常");
        e.printStackTrace();
    }
}
```

可以用`setUncaughtExceptionHandler`方法为线程安装处理器

```java
public static void main(String[] args) {
    Runnable r = () -> {
        throw new RuntimeException("抛出了一个异常");
    };
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new 处理器());
    t.start();
}
```

打印内容如下

```
线程Thread-0抛出了异常
java.lang.RuntimeException: 抛出了一个异常
at Chapter_12.未捕获异常的处理器.lambda$main$0(未捕获异常的处理器.java:12)
at java.base/java.lang.Thread.run(Thread.java:840)
```

也可以用`setDefaultUncaughtExceptionHandler`为所有线程安装一个默认的处理器

```java
public static void main(String[] args) {
    Thread.setDefaultUncaughtExceptionHandler(new 处理器());
    int i = 1/0;
}
```

运行后打印内容如下

```
线程main抛出了异常
java.lang.ArithmeticException: / by zero
at Chapter_12.未捕获异常的处理器.main(未捕获异常的处理器.java:12)
```

## 12.3.5 线程优先级

在Java中每个线程有一个优先级，最低为1,最高为10,默认为5

当线程调度器选择线程时会优先选择优先级高的线程。

虽然Java提供了设置线程优先级的机制，但是现在一般不推荐依赖线程优先级来控制并发行为，因为它的行为在不同的系统和JVM实现中可能会有很大的差异。

# 12.4 同步

在多线程应用中，多个线程可能访问同一个对象，并且分别调用了修改对象的方法。

此时，两个线程会相互覆盖。取决于线程访问数据的次序，可能导致对象被破坏。

这被称为竞态条件(race condition)

## 12.4.1 竞态条件的一个例子

```java
public class 竞态条件的一个例子 {
    private static int sharedVariable = 0;

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for ( int i = 0; i < 1000; i++ ) {
                sharedVariable++;
            }
        });

        Thread thread2 = new Thread(() -> {
            for ( int i = 0; i < 1000; i++ ) {
                sharedVariable--;
            }
        });
        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final value of shared variable: " + sharedVariable);
    }
}
```

运行几次后打印内容如下:

```
Final value of shared variable: -200
```

按理来说这个变量自增了一千次，并且自减了一千次应该最后结果为0，但是结果并非如预期那样。

## 12.4.2 竞态条件详解

当两个线程执行对变量的操作，这个操作并非是原子操作。可能有如下处理

1. 将变量加载到寄存器
2. 增加\减少变量
3. 结果写回变量

假设此时的变量值为1。

- 线程1执行了前两步，此时线程1寄存器中的变量为2
- 此时线程2被唤醒并更新变量的值
  	1. 取出未被线程1更新的变量值，也就是1
  	1. 对变量值进行减少，从1变为0
  	1. 将0存储回原变量
- 此时然后线程1被唤醒完成第三步，将线程1寄存器中的2存储回原变量

此时原本应该为0的数就变成了2

## 12.4.3 锁对象

我们可以用`ReentrantLock`确保任何时刻只有一个线程进入临界区。

一旦一个线程锁定了锁对象，其他线程都无法通过`lock`语句。

其他线程调用`lock`时，它们会暂停直到一个线程释放这个锁对象

主函数内容如下：

```java
public static void main(String[] args) {
    Thread thread1 = new Thread(() -> {
        for ( int i = 0; i < 1000000; i++ ) {
            plus();
        }
    });

    Thread thread2 = new Thread(() -> {
        for ( int i = 0; i < 1000000; i++ ) {
            plus();
        }
    });
    thread1.start();
    thread2.start();

    try {
        thread1.join();
        thread2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("Final value of shared variable: " + sharedVariable);
}
```

其中的`plus`方法内容是为`sharedVariable`变量+1

此时的`plus`方法没有加锁：

```java
private static void plus(){
    sharedVariable++;
}
```

最终结果如下：

```java
Final value of shared variable: 1661649
```

可以看到结果并非是预料的2000000

当我们添加锁之后：

```java
private static void plus(){
    reentrantLock.lock();
    try{
        sharedVariable++;
    } finally {
        reentrantLock.unlock();
    }
}
```

运行程序结果如下：

```java
Final value of shared variable: 2000000
```

这个锁被称为`重入锁(reentrant)`，线程可以反复获取已拥有的锁。锁有一个持有计数器跟踪对`lock`方法的嵌套调用

可重入性的主要应用场景是为了避免死锁。考虑一个情况，一个线程在持有一个锁的同时，又试图去获取同一个锁，如果锁是不可重入的，那么这个线程将会因为等待自己持有的锁而被永久阻塞，从而产生死锁。但是如果锁是可重入的，那么这个线程可以再次获取它已经持有的锁，从而避免死锁。

例如:

```java
public class 锁嵌套 {

    private static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        lock.lock();
        try {
            System.out.println("外层锁 HoldCount: " + lock.getHoldCount());
            lock.lock();
            try {
                System.out.println("内层锁 HoldCount: " + lock.getHoldCount());
            } finally {
                lock.unlock();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

运行后打印内容如下：

```java
外层锁 HoldCount: 1
内层锁 HoldCount: 2
```

当其持有计数为0时，线程释放锁

## 12.4.4 条件对象

通常，线程进入临界区后却发现只有满足了某个条件它才能执行。

可以用条件对象来管理那些已经获得了一个锁却不能有效工作的线程。

```java
// 创建一个可重入锁
private static ReentrantLock lock = new ReentrantLock();

// 创建一个条件对象，用于线程间的协调
private static Condition lessThan233 = lock.newCondition();
```

假设我们此时有一个余额为0的账户，和两个方法，存钱以及消费

```java
// 定义一个共享变量，表示账户的余额
private static double money = 0;

// 定义一个共享变量，表示消费的次数
private static int count = 0;
```

假设每次我们买的东西都是233元，那么我们必须拥有至少233元的存款才可以消费

对于消费方法，当余额小于233元的时候我们调用条件对象的`await`方法使其阻塞。

```java
// 消费方法
public static void spend() {
    System.out.println("开始消费");
    // 获取锁
    lock.lock();
    try {
        // 如果余额小于233，就等待
        while ( money < 233 ) {
            lessThan233.await();
        }
        // 消费233元
        money -= 233;
        // 消费次数加1
        count++;
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

对于存款方法，我们首先要确保存款是一次完整的操作，所以需要加上锁

然后是每次进行存款后，调用条件对象的`signalAll`方法

`signalAll`方法并不会立即激活一个等待的线程，而是解除等待线程的阻塞状态，使这些线程可以在当前线程释放锁之后竞争访问对象

还有一个`signal`方法，它会随机选择等待集中的一个线程，并解除线程阻塞状态。

但这也有危险，当它发现自己不能运行时，它就会再次被阻塞。

如果没有其它线程调用`signal`方法，就会导致死锁。

```java
// 存款方法
public static void addMoney(double money) {
    // 获取锁
    lock.lock();
    try {
        // 增加余额
        条件对象.money += money;
        System.out.println("存入: " + money + " 余额: " + 条件对象.money);
        // 如果余额大于等于233，唤醒所有等待的线程
        if ( 条件对象.money >= 233 ) {
            lessThan233.signalAll();
        }
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

最后在主方法中调用这两个方法：

```java
public static void main(String[] args) {
    Random r = new Random();
    // 创建一个线程，用于存款
    Thread t1 = new Thread(() -> {
        for ( int i = 0; i < 10000; i++ ) {
            addMoney(r.nextDouble(5));
        }
    });
    // 创建一个线程，用于消费
    Thread t2 = new Thread(() -> {
        for ( int i = 0; i < 100; i++ ) {
            spend();
        }
    });
    // 启动两个线程
    t1.start();
    t2.start();
    try {
        // 等待两个线程都结束
        t1.join();
        t2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // 打印最后的余额和消费次数
    System.out.println("余额: " + money);
    System.out.println("消费次数: " + count);
}
```

最后虽然能运行成功，是因为每次消费后都有足够的存钱机会使得其最终能够花出去100次。

如果消费次数更多或者存款次数更少的话，就有可能导致程序卡住

这是因为在所有的钱都被消费完之后，消费线程可能会永久地等待更多的钱被添加。这是因为在`spend`方法中，当`money`小于233时，线程会调用`lessThan233.await()`方法进入等待状态，直到其他线程调用`lessThan233.signalAll()`方法。如果没有更多的钱被添加，那么消费线程就会永久地等待。 

这也就是`活锁`

## 12.4.5 synchronized关键字

首先对锁和条件的要点做一个总结

- 锁用来保护代码段，一次只允许一个线程执行被保护的代码
- 锁可以管理试图进入被保护代码段的线程
- 一个锁可以有一个或多个关联的条件对象
- 每个条件对象管理那些已经被保护代码段但还不能运行的线程

`Lock`和`Condition`允许程序员充分控制锁定，但大多数情况下不需要那样控制。

1.0版本开始，java中的每个对象都有一个内部锁，在方法声明时带有`synchronized`，那么对象的锁将会保护整个方法，调用这个方法必须获得内部对象锁

之前的`plus`方法是由`ReentrantLock`来添加锁的。

```java
private static void plus(){
    reentrantLock.lock();
    try{
        sharedVariable++;
    } finally {
        reentrantLock.unlock();
    }
}
```

当我们使用`synchronized`关键字时，上述方法等价于：

```java
private synchronized void plus(){
    sharedVariable++;
}
```

内部对象锁只有一个关联条件。`wait`方法将一个线程增加到等待集中，`notifyAll/notify`解除等待线程的阻塞。

`wait`相当于条件对象的`await`方法，`notifyAll`相当于条件对象的`signAll`方法

那么我们可以改造之前的代码使其更为简洁

```java
public class 锁对象 {
    private static int sharedVariable = 0;

    private static ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for ( int i = 0; i < 1000000; i++ ) {
                plus();
            }
        });

        Thread thread2 = new Thread(() -> {
            for ( int i = 0; i < 1000000; i++ ) {
                plus();
            }
        });
        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final value of shared variable: " + sharedVariable);
    }

    //    private static void plus(){
    //        reentrantLock.lock();
    //        try{
    //            sharedVariable++;
    //        } finally {
    //            reentrantLock.unlock();
    //        }
    //    }

    private static synchronized void plus(){
        sharedVariable++;
    }
}
```

内部锁和条件存在一些限制。包括：

- 不能中断一个正在获取锁的线程
- 不能指定尝试获取锁的超时时间
- 每个锁只有一个条件，这很低效。

在平时的开发中，对于锁的选择有以下几点

- 最好不使用以上介绍的两种锁，而是使用`java.util.concurrent`包中的一些机制，它会处理所有的锁定。
- 如果`synchronized`关键字适合你的程序，请使用这种方法
- 需要`Lock/Condition`结构提供的额外能力，此时使用它们

## 12.4.6 同步块

进入一个同步块也可以获得这个锁，形式如下：

```java
public static void plus(){
    synchronized (lock){
        sharedVariable++;
    }
}
```

如果要使用同步块一定要了解你的锁对象。

## 12.4.8 volatile字段

考虑如下两个方法

```java
private boolean done;
public synchronized boolean isDone() {
    return done;
}

public synchronized void setDone(boolean done) {
    this.done = done;
}
```

done的值由一个线程设置，而由另一个线程查询。

但如果另一个线程已对该对象加锁，那么这两个方法可能会堵塞

这种情况下使用`volatile`就很合适，可以确保当其中一个线程对`done`变量修改后，这个修改对读取这个变量的所有线程都可见。

```java
private volatile boolean done;
public synchronized boolean isDone() {
    return done;
}

public synchronized void setDone(boolean done) {
    this.done = done;
}
```

## 12.4.9 final变量

在Java中，final关键字用于声明一个变量的值在初始化后就不能再被修改。这对于多线程环境有一些重要的影响：  

- 不可变性：final变量的不可变性使得它在多线程环境中是安全的，因为一旦final变量被初始化，任何线程都不能改变它的值。这消除了需要同步访问变量的需求，因为所有线程都会看到相同的值。 

- 内存可见性：在Java内存模型中，final字段的写入和读取有特殊的规则。当对象构造完成后，final字段的值对所有线程都是可见的，即使没有使用同步。这是因为final字段的写入操作会在构造函数的结束处插入一个内存屏障，强制将final字段的值刷新到主内存，并阻止指令重排序

- 禁止指令重排序：编译器会确保在构造函数内对final字段的赋值操作，不会被编译器优化而进行指令重排序。这意味着，final字段在构造函数完成后，其值就不会改变。 

  需要注意的是，虽然final字段本身是不可变的，但如果final字段是一个引用类型，那么这个引用指向的对象可能是可变的。例如，一个final的数组或集合，数组或集合本身的内容是可以改变的。如果需要确保线程安全，还需要额外的同步措施。  

  总的来说，final关键字在多线程环境中提供了一种简单而有效的方式来创建不可变的数据，这对于构建线程安全的程序是非常有用的。

## 12.4.10 原子性

`java.util.concurrent.atomic`包提供很高校的机器指令来保证其他操作的原子性（没有使用锁）。

例如`incrementAndGet`方法，可以保证以原子方式对一个正数完成自增操作，用它修改`plus`方法的代码如下所示。

```java
public static void main(String[] args) {
    Integer value = 0;
    AtomicInteger atomicInteger = new AtomicInteger(value);
    var t2 = new Thread(() -> {
        for (int i = 0; i < 100000; i++) {
            atomicInteger.incrementAndGet();
        }
    });

    var t1 = new Thread(() -> {
        for (int i = 0; i < 100000; i++) {
            atomicInteger.incrementAndGet();
        }
    });
    t1.start();
    t2.start();

    try {
        t1.join();
        t2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        System.out.println(value);
    }
}
```

最终结果是200000

如果预期可能存在大量竞争，只需要使用`LongAdder`而不是`AtomicLong`。

当工作完成后才需要总和的值的情况下，这种方式更高效

```java
private static LongAdder adder = new LongAdder();

//private static AtomicInteger adder = new AtomicInteger(0);
public static void main(String[] args) {
    LocalDateTime now = LocalDateTime.now();
    var t2 = new Thread(() -> {
        for (int i = 0; i < 100000000; i++) {
            adder.incrementAndGet();
        }
    });
    var t1 = new Thread(() -> {
        for (int i = 0; i < 100000000; i++) {
            adder.incrementAndGet();
        }
    });
    t1.start();
    t2.start();
    try {
        t1.join();
        t2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        LocalDateTime end = LocalDateTime.now();
        System.out.println("耗时：" + ChronoUnit.MILLIS.between(now, end) + "毫秒");
        System.out.println(adder.get());
    }
}
```

这种情况下完成这么多次数的累加需要310毫秒，而`AtomicInteger`则需要2000毫秒左右来完成这些任务

因为大量线程会访问相同的原子值，性能会大幅下降。

`LongAccumlator`将这种思想推广到任意的累加操作。

效率和`LongAdder`相近

```java
private static LongAccumulator adder = new LongAccumulator(Long::sum, 0);

......
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        var t2 = new Thread(() -> {
            for (int i = 0; i < 100000000; i++) {
                adder.accumulate(1);
            }
        });
        var t1 = new Thread(() -> {
            for (int i = 0; i < 100000000; i++) {
                adder.accumulate(1);
            }
        });
......
```

## 12.4.11 死锁

```java
public static void main(String[] args) {
    Thread thread1 = new Thread(() -> {
        try {
            lock.lock();
            System.out.println("Thread 1: locked");
            Thread.sleep(1000);
            lock.lock(); // 尝试再次获取锁
            System.out.println("Thread 1: locked again");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    });

    Thread thread2 = new Thread(() -> {
        try {
            Thread.sleep(500); // 等待线程1获取锁
            lock.lock(); // 尝试获取锁
            System.out.println("Thread 2: locked");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    });

    thread1.start();
    thread2.start();
}
```

1. 线程1首先获取了锁，然后进入睡眠状态。

2. 在线程1睡眠期间，线程2试图获取锁，但是由于线程1已经持有锁，所以线程2被阻塞，等待线程1释放锁。

3. 线程1醒来后，试图再次获取锁。但是，由于线程2正在等待获取锁，线程1无法再次获取锁，因此线程1也被阻塞。

   这就导致了死锁：线程1和线程2都在等待对方释放锁，但是都不会释放自己持有的锁。

在Java中并没有解决死锁的方法，所以必须谨慎地设计程序

## 12.4.12 线程局部变量

线程间共享变量可能是不安全的，有时要避免共享变量，使用`ThreadLocal`辅助类为各个线程提供各自的实例

考虑一个静态变量`static dateFormat = SimpleDateFormat("yyyy-MM-DD")`

当两个线程都执行`String date = dateFormat.format(new Date())`

就会导致混乱的结果。当然可以使用同步，但是这样的性能开销很大，或者在需要时构建一个`SimpleDateFormat("yyyy-MM-DD")`对象，这样同样很浪费

为每个线程构建一个实例，可以考虑以下写法

```java
public static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);
```

在一个给定线程首次调用`get`时，会调用`lambda`表达式构建一个属于当前线程的实例

```java
public class 线程局部变量 {

    public static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);


    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            threadLocal.set(233);
            System.out.println(Thread.currentThread().getName() + "的threadLocal值为：" + threadLocal.get());
        });

        Thread t2 = new Thread(() -> {
            threadLocal.set(666);
            System.out.println(Thread.currentThread().getName() + "的threadLocal值为：" + threadLocal.get());
        });
        t1.start();
        t2.start();

    }
}
```

打印结果为

```java
Thread-1的threadLocal值为：666
Thread-0的threadLocal值为：233
```

一些线程安全的类，比如`Random`类

如果多个线程等待一个共享的随机数生成器，这会很低效。

可以调用如下方法

```java
int random = ThreadLocalRandom.current().nextInt(upperBound);
```

# 12.5 线程安全的集合

当我们在多个线程中修改数组或是列表时，很容易破坏这种数据结果，我们可以使用锁保护共享的数据结构，但是更通常的做法是选择线程安全的实现。

## 12.5.1 阻塞队列

生产者队列向队列插入元素，消费者线程获取元素

使用阻塞队列可以使线程间安全地传递数据。

考虑银行转账时，将转账指令对象插入队列，而不是直接访问银行对象。

另一个线程从队列中取出指令并完成转账。只有这个线程可以访问银行对象的内部，因此不需要同步。

当向阻塞队列添加元素或者从队列移除元素但队列为空时，阻塞队列将导致线程阻塞。

阻塞队列会周期性地将中间结果存储。其他工作线程移除中间结果。

它还会自动平衡负载。如果第一组线程运行慢，第二组会在等待时阻塞。

阻塞队列的主要方法可以分为以下四类：  

1. 抛出异常类：当阻塞队列满时，再往队列里插入元素会抛出IllegalStateException异常；当阻塞队列空时，从队列里获取元素会抛出NoSuchElementException异常。 

   > add(e)
   > remove()
   > element()

2. 返回特殊值类：插入方法会返回是否成功，成功则返回true，失败（队列已满）则返回false；移除方法，成功返回出队列的元素，队列里没有就返回null。 

   > offer(e)
   > poll()
   > peek()

3. 一直阻塞类：当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程，直到put数据or响应中断退出；当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程，直到队列可用。 

   > put(e)
   > take()

4. 超时退出类：当阻塞队列满时，队列会阻塞生产者线程一定的时间，超过限时后生产者线程会退出；当阻塞队列空时，消费者线程试图从队列里获取元素，队列会阻塞消费者线程一定的时间，超过限时后消费者线程会退出。 

   > offer(e, time, unit)
   > poll(time, unit)

```java
public class 阻塞队列 {

    public static ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);

    public static Random r = new Random();
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for ( int i = 0; i < 10; i++ ) {
                boolean offer = queue.offer(i);
                if(offer) {
                    System.out.println("生产者生产了：" + i);
                }else{
                    System.out.println("队列已满");
                    System.out.println("生产者等待");
                }
            }
        });
        Thread t2 = new Thread(() -> {
            for ( int i = 0; i < 10; i++ ) {
                var poll = queue.poll();
                if(poll == null) {
                    System.out.println("队列为空");
                    System.out.println("消费者等待");
                } else {
                    System.out.println("消费者消费了：" + poll);
                }
            }
        });
        t1.start();
        t2.start();
    }
}
```

运行结束后打印结果如下：

```java
消费者消费了：0
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
队列为空
消费者等待
生产者生产了：0
生产者生产了：1
生产者生产了：2
生产者生产了：3
队列已满
生产者等待
队列已满
生产者等待
队列已满
生产者等待
队列已满
生产者等待
队列已满
生产者等待
队列已满
生产者等待
```

可以看到消费者先消费了十次，然后生产者又生产了十次，当队列满的时候`offer`返回了`false`，所以无法继续生产，而消费者端试图获取队列内容时发现队列为空，`poll`直接返回了false，其后续也无法进行消费。

## 12.5.2 高效的映射、集和散列

在`java.util.concurrent`包中提供了映射，集合和队列的高效实现

它们运行并发访问数据结构不同部分并尽可能地减少竞争

## 12.5.3 映射条目的原子更新

Java API提供了一些新方法可以更方便地完成原子更新。

调用`compute`方法并提供一个计算新值的函数

```java
map.compute(word,(k,v) -> v == null ? 1 : v+1)
```

它们使用方法类似`merge`方法

同样的`compute`方法也有`computeIfAbesent`和`computeIfPresent`方法在不同的情况下计算新值。

## 12.5.4 并发散列映射的批操作

JAVA API为并发散列提供了批操作，其实有其他线程在处理映射，这些操作也能安全执行，批操作会遍历或处理映射中的元素。

不过这不会冻结映射的状态，除非你知道映射不会在中途被修改，否则应当把结果看作映射状态的近似。

有三种不同的操作

- search 为每个键或值应用一个函数，直到函数生成一个非null的结果，返回这个结果
- reduce 组合所有键和值
- forEach 为所有键或值应用一个函数

我们可以对比一下`HashMap`和`并发映射`的速度

```java
public static void main(String[] args) {
    var map = new HashMap<Integer, Integer>();
    for ( int i = 0; i < 15; i++ ) {
        map.put(i, i);
    }
    LocalDateTime begin = LocalDateTime.now();
    map.forEach( (k, v) -> {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
    LocalDateTime end = LocalDateTime.now();
    System.out.println("耗时：" + ChronoUnit.MILLIS.between(begin,end) + "毫秒");
}
```

这段代码更新所有的元素，让其的值+1

总耗时在7599毫秒左右

换成并发映射来重新测试一下

```java
public static void main(String[] args) {
    var map = new ConcurrentHashMap<Integer, Integer>(5);
    for ( int i = 0; i < 15; i++ ) {
        map.put(i, i);
    }
    LocalDateTime begin = LocalDateTime.now();
    map.forEach(1, (k, v) -> {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
    LocalDateTime end = LocalDateTime.now();
    System.out.println("耗时：" + ChronoUnit.MILLIS.between(begin,end) + "毫秒");
}
```

此时运行时间只有1022毫秒，快了7倍

## 12.5.5 并发集试图

如果想要一个很大的线程安全的集而不是映射，请使用`Set<String> set = newKeySet();`

## 12.5.6 写时拷贝数组

`CopyOnWriteArrayList`是Java并发包`java.util.concurrent`中提供的一个线程安全的`ArrayList`。它的主要特性是每次对列表进行修改操作（如add，set等）时，都会创建底层数组的一个新副本。这种方式通常代价较高，但在遍历操作远多于修改操作时，可能比其他方法更高效。当你无法或不想同步遍历操作，但需要防止并发线程之间的干扰时，`CopyOnWriteArrayList`非常有用。 

对于`Set`，也有与之对应的`CopyOnWriteArraySet`

## 12.5.7 并行数组算法

对于数组，Arrays类提供了大量并行化操作。

我们首先让一个拥有一千万个数字的列表进行排序

```java
public static void main(String[] args) {
    Random r = new Random();
    var arr = new Long[10000000];
    for ( int i = 0; i < 10000000; i++ ) {
        arr[i] = r.nextLong();
    }
    LocalDateTime begin = LocalDateTime.now();
    Arrays.sort(arr);
    LocalDateTime end = LocalDateTime.now();
    System.out.println("耗时：" + ChronoUnit.MILLIS.between(begin,end) + "毫秒");
}
```

最终耗时5011毫秒

当我们使用并行操作来排序的时候

```java
public static void main(String[] args) {
    Random r = new Random();
    var arr = new Long[10000000];
    for ( int i = 0; i < 10000000; i++ ) {
        arr[i] = r.nextLong();
    }
    LocalDateTime begin = LocalDateTime.now();
    Arrays.parallelSort(arr);
    LocalDateTime end = LocalDateTime.now();
    System.out.println("耗时：" + ChronoUnit.MILLIS.between(begin,end) + "毫秒");
}
```

最终耗时仅1436毫秒，快了三倍。

# 12.6 任务和线程池















