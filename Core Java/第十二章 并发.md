# 简单的线程示例

1. 将执行任务的代码放在一个类的`run`方法中，类要实现`Runnable`接口。`Runnable`内部十分简单，只有一个`run`方法

   ```java
   @FunctionalInterface
   public interface Runnable {
       public abstract void run();
   }
   ```

   `Runnable`是一个函数式接口，所以可以用lambda表达式创建实例

2. 从`Runnable`构造一个`Thread`对象

   ```java
   Thread t = new Thread(r);
   ```

3. 启动线程

   ```java
   t.start();
   ```

组合在一起代码如下：

```java
new Thread(() -> {
    for (int i = 0; i < 100; i++) {
        System.out.println("Hello, World! Two!");
    }
}).start();
new Thread(()->{
    for (int i = 0; i < 100; i++) {
        System.out.println("Hello, World! One!");
    }
}).start();
```

打印内容部分如下：

```text
………
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! Two!
Hello, World! One!
Hello, World! One!
Hello, World! One!
Hello, World! One!
………
```

可以看到输出是交错的

# 12.2 线程状态

线程有如下六种状态：

- New(新建)

- Runnable(可运行)

- Blocked(阻塞)

- Waiting(等待)

- Timed waiting(计时等待)

- Terminated(终止)

  可以用`getState`方法确定线程状态

<img src="https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202024-04-01%2012.31.jpg" alt="扫描全能王 2024-04-01 12.31" style="zoom: 25%;" />

# 12.3 线程属性

## 12.3.1 中断线程

当线程内程序执行完成或者出现未捕获的异常时，这个线程将终止。

除了已经废弃的stop方法没有办法使一个线程终止。

不过现在有`interrut`方法可以请求终止一个线程

当使用这个方法后，线程就会被设置为中断状态`interrupted status`。每个线程都有这样一个boolean标准。各个线程都应该不时地检查这个标志

要确定是否终端可以先获取当前线程`Thread.currentThread`然后调用`isInterrupted`方法

```java
public static void main(String[] args) {
    // 创建一个Runnable对象，定义线程要执行的任务
    Runnable r = () -> {
        int i = 233;
        // 循环执行任务
        for ( int j = 0; j < i; j++ ) {
            // 打印当前是第几次循环
            System.out.println("当前是第" + j + "次循环");
            // 当循环到第10次时，中断当前线程
            if(j == 10){
                Thread.currentThread().interrupt();
            }
            // 检查当前线程是否被中断
            if(Thread.currentThread().isInterrupted()){
                // 如果线程被中断，打印一条消息并退出循环
                System.out.println("线程被中断");
                break;
            }
        }
    };
    // 创建一个新的线程
    Thread t = new Thread(r);
    // 启动线程
    t.start();
}
```

运行后打印内容如下

```
当前是第0次循环
当前是第1次循环
当前是第2次循环
当前是第3次循环
当前是第4次循环
当前是第5次循环
当前是第6次循环
当前是第7次循环
当前是第8次循环
当前是第9次循环
当前是第10次循环
线程被中断
```

如果每次执行后调用`sleep()`方法或者其他中断方法,既没有必要也没有用处。此时调用`sleep`方法不会休眠，同时会清除`中断状态`并抛出`InterruptedException`

所以如果使用`sleep`方法应当捕获`InterruptedException`而非检查中断状态

```java
public static void sleep方法和中断状态(){
    // 创建一个Runnable对象，定义线程要执行的任务
    Runnable r = () -> {
        int i = 233;
        try{
            // 循环执行任务
            for ( int j = 0; j < i;  j++ ) {
                // 打印当前是第几次循环
                System.out.println("当前是第" + j + "次循环");
                // 线程暂停300毫秒
                Thread.sleep(300);
                // 当循环到第10次时，中断当前线程
                if(j == 10){
                    Thread.currentThread().interrupt();
                }
            }
        } catch (InterruptedException e) {
            // 如果线程在睡眠状态下被中断，打印线程的中断状态
            System.out.println(Thread.currentThread().isInterrupted());
            // 打印一条消息并退出循环
            System.out.println("线程被中断");
            // 抛出运行时异常
            throw new RuntimeException(e);
        }
    };
    // 创建一个新的线程
    Thread t = new Thread(r);
    // 启动线程
    t.start();
}
```

或者也可以为整个方法抛出异常，这样调用者就知道发生了什么

```java
public static void sleep方法和中断状态() throws InterruptedException {
    int i = 233;
    for ( int j = 0; j < i; j++ ) {
        System.out.println("当前是第" + j + "次循环");
        if ( j == 10 ) {
            Thread.currentThread().interrupt();
        }
        Thread.sleep(300);
    }
}
```

调用它的main方法如下：

```java
public static void main(String[] args) throws InterruptedException {
    Runnable r = () ->{
        try {
            sleep方法和中断状态();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    };
    Thread t = new Thread(r);
    t.start();
}
```



## 12.3.2 守护线程

可以调用`t.setDaemon(true)`。它唯一的作用是给其他线程提供服务，如计时服务等。

清空果实缓存项的线程也是守护线程，只剩下守护线程，虚拟机就会退出。

## 12.3.3 线程名

可以用`t.setName("Wwhds t")`为线程设置名字

## 12.3.4 未捕获异常的处理器

线程的`run`方法不能抛出任何检查型异常，但是非检查型异常可能导致线程终止，这种情况下线程会死亡

在线程死亡前，会传递到一个用于处理未捕获异常的处理器

这个处理器必须属于一个实现了`Thread.UncaughtExceptionHandler`的类

```java
class 处理器 implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("线程" + t.getName() + "抛出了异常");
        e.printStackTrace();
    }
}
```

可以用`setUncaughtExceptionHandler`方法为线程安装处理器

```java
public static void main(String[] args) {
    Runnable r = () -> {
        throw new RuntimeException("抛出了一个异常");
    };
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler(new 处理器());
    t.start();
}
```

打印内容如下

```
线程Thread-0抛出了异常
java.lang.RuntimeException: 抛出了一个异常
at Chapter_12.未捕获异常的处理器.lambda$main$0(未捕获异常的处理器.java:12)
at java.base/java.lang.Thread.run(Thread.java:840)
```

也可以用`setDefaultUncaughtExceptionHandler`为所有线程安装一个默认的处理器

```java
public static void main(String[] args) {
    Thread.setDefaultUncaughtExceptionHandler(new 处理器());
    int i = 1/0;
}
```

运行后打印内容如下

```
线程main抛出了异常
java.lang.ArithmeticException: / by zero
at Chapter_12.未捕获异常的处理器.main(未捕获异常的处理器.java:12)
```

## 12.3.5 线程优先级

在Java中每个线程有一个优先级，最低为1,最高为10,默认为5

当线程调度器选择线程时会优先选择优先级高的线程。

虽然Java提供了设置线程优先级的机制，但是现在一般不推荐依赖线程优先级来控制并发行为，因为它的行为在不同的系统和JVM实现中可能会有很大的差异。

# 12.4 同步

在多线程应用中，多个线程可能访问同一个对象，并且分别调用了修改对象的方法。

此时，两个线程会相互覆盖。取决于线程访问数据的次序，可能导致对象被破坏。

这被称为竞态条件(race condition)

## 12.4.1 竞态条件的一个例子

```java
public class 竞态条件的一个例子 {
    private static int sharedVariable = 0;

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for ( int i = 0; i < 1000; i++ ) {
                sharedVariable++;
            }
        });

        Thread thread2 = new Thread(() -> {
            for ( int i = 0; i < 1000; i++ ) {
                sharedVariable--;
            }
        });
        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final value of shared variable: " + sharedVariable);
    }
}
```

运行几次后打印内容如下:

```
Final value of shared variable: -200
```

按理来说这个变量自增了一千次，并且自减了一千次应该最后结果为0，但是结果并非如预期那样。

## 12.4.2 竞态条件详解

当两个线程执行对变量的操作，这个操作并非是原子操作。可能有如下处理

1. 将变量加载到寄存器
2. 增加\减少变量
3. 结果写回变量

假设此时的变量值为1。

- 线程1执行了前两步，此时线程1寄存器中的变量为2
- 此时线程2被唤醒并更新变量的值
  	1. 取出未被线程1更新的变量值，也就是1
  	1. 对变量值进行减少，从1变为0
  	1. 将0存储回原变量
- 此时然后线程1被唤醒完成第三步，将线程1寄存器中的2存储回原变量

此时原本应该为0的数就变成了2

## 12.4.3 锁对象

我们可以用`ReentrantLock`确保任何时刻只有一个线程进入临界区。

一旦一个线程锁定了锁对象，其他线程都无法通过`lock`语句。

其他线程调用`lock`时，它们会暂停直到一个线程释放这个锁对象

主函数内容如下：

```java
public static void main(String[] args) {
    Thread thread1 = new Thread(() -> {
        for ( int i = 0; i < 1000000; i++ ) {
            plus();
        }
    });

    Thread thread2 = new Thread(() -> {
        for ( int i = 0; i < 1000000; i++ ) {
            plus();
        }
    });
    thread1.start();
    thread2.start();

    try {
        thread1.join();
        thread2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("Final value of shared variable: " + sharedVariable);
}
```

其中的`plus`方法内容是为`sharedVariable`变量+1

此时的`plus`方法没有加锁：

```java
private static void plus(){
    sharedVariable++;
}
```

最终结果如下：

```java
Final value of shared variable: 1661649
```

可以看到结果并非是预料的2000000

当我们添加锁之后：

```java
private static void plus(){
    reentrantLock.lock();
    try{
        sharedVariable++;
    } finally {
        reentrantLock.unlock();
    }
}
```

运行程序结果如下：

```java
Final value of shared variable: 2000000
```

这个锁被称为`重入锁(reentrant)`，线程可以反复获取已拥有的锁。锁有一个持有计数器跟踪对`lock`方法的嵌套调用

可重入性的主要应用场景是为了避免死锁。考虑一个情况，一个线程在持有一个锁的同时，又试图去获取同一个锁，如果锁是不可重入的，那么这个线程将会因为等待自己持有的锁而被永久阻塞，从而产生死锁。但是如果锁是可重入的，那么这个线程可以再次获取它已经持有的锁，从而避免死锁。

例如:

```java
public class 锁嵌套 {

    private static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        lock.lock();
        try {
            System.out.println("外层锁 HoldCount: " + lock.getHoldCount());
            lock.lock();
            try {
                System.out.println("内层锁 HoldCount: " + lock.getHoldCount());
            } finally {
                lock.unlock();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

运行后打印内容如下：

```java
外层锁 HoldCount: 1
内层锁 HoldCount: 2
```

当其持有计数为0时，线程释放锁

## 12.4.4 条件对象

通常，线程进入临界区后却发现只有满足了某个条件它才能执行。

可以用条件对象来管理那些已经获得了一个锁却不能有效工作的线程。

```java
// 创建一个可重入锁
private static ReentrantLock lock = new ReentrantLock();

// 创建一个条件对象，用于线程间的协调
private static Condition lessThan233 = lock.newCondition();
```

假设我们此时有一个余额为0的账户，和两个方法，存钱以及消费

```java
// 定义一个共享变量，表示账户的余额
private static double money = 0;

// 定义一个共享变量，表示消费的次数
private static int count = 0;
```

假设每次我们买的东西都是233元，那么我们必须拥有至少233元的存款才可以消费

对于消费方法，当余额小于233元的时候我们调用条件对象的`await`方法使其阻塞。

```java
// 消费方法
public static void spend() {
    System.out.println("开始消费");
    // 获取锁
    lock.lock();
    try {
        // 如果余额小于233，就等待
        while ( money < 233 ) {
            lessThan233.await();
        }
        // 消费233元
        money -= 233;
        // 消费次数加1
        count++;
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

对于存款方法，我们首先要确保存款是一次完整的操作，所以需要加上锁

然后是每次进行存款后，调用条件对象的`signalAll`方法

`signalAll`方法并不会立即激活一个等待的线程，而是解除等待线程的阻塞状态，使这些线程可以在当前线程释放锁之后竞争访问对象

还有一个`signal`方法，它会随机选择等待集中的一个线程，并解除线程阻塞状态。

但这也有危险，当它发现自己不能运行时，它就会再次被阻塞。

如果没有其它线程调用`signal`方法，就会导致死锁。

```java
// 存款方法
public static void addMoney(double money) {
    // 获取锁
    lock.lock();
    try {
        // 增加余额
        条件对象.money += money;
        System.out.println("存入: " + money + " 余额: " + 条件对象.money);
        // 如果余额大于等于233，唤醒所有等待的线程
        if ( 条件对象.money >= 233 ) {
            lessThan233.signalAll();
        }
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

最后在主方法中调用这两个方法：

```java
public static void main(String[] args) {
    Random r = new Random();
    // 创建一个线程，用于存款
    Thread t1 = new Thread(() -> {
        for ( int i = 0; i < 10000; i++ ) {
            addMoney(r.nextDouble(5));
        }
    });
    // 创建一个线程，用于消费
    Thread t2 = new Thread(() -> {
        for ( int i = 0; i < 100; i++ ) {
            spend();
        }
    });
    // 启动两个线程
    t1.start();
    t2.start();
    try {
        // 等待两个线程都结束
        t1.join();
        t2.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // 打印最后的余额和消费次数
    System.out.println("余额: " + money);
    System.out.println("消费次数: " + count);
}
```

最后虽然能运行成功，是因为每次消费后都有足够的存钱机会使得其最终能够花出去100次。

如果消费次数更多或者存款次数更少的话，就有可能导致程序卡住

这是因为在所有的钱都被消费完之后，消费线程可能会永久地等待更多的钱被添加。这是因为在`spend`方法中，当`money`小于233时，线程会调用`lessThan233.await()`方法进入等待状态，直到其他线程调用`lessThan233.signalAll()`方法。如果没有更多的钱被添加，那么消费线程就会永久地等待。 

这也就是`活锁`

## 12.4.5 synchronized关键字

首先对锁和条件的要点做一个总结

- 锁用来保护代码段，一次只允许一个线程执行被保护的代码
- 锁可以管理试图进入被保护代码段的线程
- 一个锁可以有一个或多个关联的条件对象
- 每个条件对象管理那些已经被保护代码段但还不能运行的线程

`Lock`和`Condition`允许程序员充分控制锁定，但大多数情况下不需要那样控制。

1.0版本开始，java中的每个对象都有一个内部锁，在方法声明时带有`synchronized`，那么对象的锁将会保护整个方法，调用这个方法必须获得内部对象锁

之前的`plus`方法是由`ReentrantLock`来添加锁的。

```java
private static void plus(){
    reentrantLock.lock();
    try{
        sharedVariable++;
    } finally {
        reentrantLock.unlock();
    }
}
```

当我们使用`synchronized`关键字时，上述方法等价于：

```java
private synchronized void plus(){
    sharedVariable++;
}
```

内部对象锁只有一个关联条件。`wait`方法将一个线程增加到等待集中，`notifyAll/notify`解除等待线程的阻塞。

`wait`相当于条件对象的`await`方法，`notifyAll`相当于条件对象的`signAll`方法

那么我们可以改造之前的代码使其更为简洁

```java
public class 锁对象 {
    private static int sharedVariable = 0;

    private static ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for ( int i = 0; i < 1000000; i++ ) {
                plus();
            }
        });

        Thread thread2 = new Thread(() -> {
            for ( int i = 0; i < 1000000; i++ ) {
                plus();
            }
        });
        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final value of shared variable: " + sharedVariable);
    }

    //    private static void plus(){
    //        reentrantLock.lock();
    //        try{
    //            sharedVariable++;
    //        } finally {
    //            reentrantLock.unlock();
    //        }
    //    }

    private static synchronized void plus(){
        sharedVariable++;
    }
}
```

内部锁和条件存在一些限制。包括：

- 不能中断一个正在获取锁的线程
- 不能指定尝试获取锁的超时时间
- 每个锁只有一个条件，这很低效。

在平时的开发中，对于锁的选择有以下几点

- 最好不使用以上介绍的两种锁，而是使用`java.util.concurrent`包中的一些机制，它会处理所有的锁定。
- 如果`synchronized`关键字适合你的程序，请使用这种方法
- 需要`Lock/Condition`结构提供的额外能力，此时使用它们

## 12.4.6 同步块

进入一个同步块也可以获得这个锁，形式如下：

```java
public static void plus(){
    synchronized (lock){
        sharedVariable++;
    }
}
```

如果要使用同步块一定要了解你的锁对象。

## 12.4.7 监视器概念



## 12.4.8 volatile字段















