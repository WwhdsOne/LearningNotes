### 1. **String**

- **用途**: 存储字符串、整数或浮点数。
- **底层实现**: SDS (Simple Dynamic String)。

#### SDS (Simple Dynamic String)

- **多种编码格式**
  - **EMBSTR 编码**: 用于存储较短的字符串，减少内存分配和释放的开销。
  - **RAW 编码**: 用于存储较长的字符串，提供灵活性和高效操作。

- **结构**:
  - `len`: 字符串的当前长度。
  - `free`: 未使用的字节数。
  - `buf[]`: 字符数组，存储实际的字符串内容。
- **优点**:
  - **动态扩展**: 可以根据需要动态扩展字符串长度。
  - **二进制安全**: 可以存储任意二进制数据。
  - **高效操作**: 提供了高效的追加、截取等操作。

### 2. **List**

- **用途**: 存储有序的字符串列表。
- **底层实现**: 双向链表或压缩列表 (ziplist)。

#### 双向链表

- **结构**:
  - `head`: 指向链表头部的指针。
  - `tail`: 指向链表尾部的指针。
  - `len`: 链表的长度。
  - `dup`: 复制函数。
  - `free`: 释放函数。
  - `match`: 匹配函数。
- **优点**:
  - **高效插入和删除**: 在链表头部和尾部插入和删除元素的时间复杂度为 O(1)。
  - **灵活性**: 可以动态扩展和收缩。

#### 压缩列表 (ziplist)

- **结构**:
  - `zlbytes`: 压缩列表的总字节数。
  - `zltail`: 压缩列表尾部的偏移量。
  - `zllen`: 压缩列表的元素个数。
  - `entryX`: 压缩列表的元素。
  - `zlend`: 压缩列表的结束标志。
- **优点**:
  - **节省内存**: 通过压缩数据结构来节省内存。
  - **高效遍历**: 支持高效的遍历操作。

### 3. **Set**

- **用途**: 存储无序的字符串集合，不允许重复元素。
- **底层实现**: 哈希表或整数集合 (intset)。

#### 哈希表

- **结构**:
  - `dict`: 哈希表结构。
  - `ht[2]`: 两个哈希表，用于渐进式 rehash。
  - `rehashidx`: rehash 索引。
- **优点**:
  - **高效查找**: 平均时间复杂度为 O(1)。
  - **动态扩展**: 可以根据需要动态扩展哈希表大小。

#### 整数集合 (intset)

- **结构**:
  - `encoding`: 整数集合的编码方式。
  - `length`: 整数集合的长度。
  - `contents[]`: 存储整数的数组。
- **优点**:
  - **节省内存**: 只存储整数，节省内存。
  - **高效插入和删除**: 支持高效的插入和删除操作。

### 4. **Hash**

- **用途**: 存储键值对集合。
- **底层实现**: 哈希表或压缩列表 (ziplist)。

#### 哈希表

- **结构**:
  - `dict`: 哈希表结构。
  - `ht[2]`: 两个哈希表，用于渐进式 rehash。
  - `rehashidx`: rehash 索引。
- **优点**:
  - **高效查找**: 平均时间复杂度为 O(1)。
  - **动态扩展**: 可以根据需要动态扩展哈希表大小。

#### 压缩列表 (ziplist)

- **结构**:
  - `zlbytes`: 压缩列表的总字节数。
  - `zltail`: 压缩列表尾部的偏移量。
  - `zllen`: 压缩列表的元素个数。
  - `entryX`: 压缩列表的元素。
  - `zlend`: 压缩列表的结束标志。
- **优点**:
  - **节省内存**: 通过压缩数据结构来节省内存。
  - **高效遍历**: 支持高效的遍历操作。

### 5. **Sorted Set**

- **用途**: 存储有序的字符串集合，每个元素关联一个分数 (score)，根据分数排序。
- **底层实现**: 跳表 (skiplist) 或压缩列表 (ziplist)。

#### 跳表 (skiplist)

- **结构**:
  - `header`: 指向跳表头部的指针。
  - `tail`: 指向跳表尾部的指针。
  - `level`: 跳表的最大层数。
  - `length`: 跳表的元素个数。
- **优点**:
  - **高效查找**: 平均时间复杂度为 O(log N)。
  - **高效插入和删除**: 支持高效的插入和删除操作。

#### 压缩列表 (ziplist)

- **结构**:
  - `zlbytes`: 压缩列表的总字节数。
  - `zltail`: 压缩列表尾部的偏移量。
  - `zllen`: 压缩列表的元素个数。
  - `entryX`: 压缩列表的元素。
  - `zlend`: 压缩列表的结束标志。
- **优点**:
  - **节省内存**: 通过压缩数据结构来节省内存。
  - **高效遍历**: 支持高效的遍历操作。

### 总结

- **String**: 使用 SDS 实现，支持动态扩展和二进制安全。
- **List**: 使用双向链表或压缩列表实现，支持高效插入和删除。
- **Set**: 使用哈希表或整数集合实现，支持高效查找和动态扩展。
- **Hash**: 使用哈希表或压缩列表实现，支持高效查找和节省内存。
- **Sorted Set**: 使用跳表或压缩列表实现，支持高效查找和排序。

# 大key问题如何解决

1. 拆分大KEY
2. 使用Hash结构
3. 压缩数据

# 热KEY解决方案

1. 本地缓存

2. 分片

3. 冷热数据分离

4. #### 使用 Redis Cluster

# Redis底层连接原理

1. **网络通信**：
   - Redis 使用 TCP/IP 协议进行网络通信。
   - Redis 服务器监听一个或多个端口，客户端通过这些端口与服务器建立连接。
   - Redis 使用非阻塞 I/O 和事件驱动模型（如 epoll、kqueue 或 select）来处理多个客户端连接。
2. **协议**：
   - Redis 使用一种简单的文本协议（RESP，Redis Serialization Protocol）来与客户端进行通信。
   - 协议支持多种数据类型，包括简单字符串、错误、整数、批量字符串和数组。
   - 客户端发送命令到服务器，服务器返回响应。
3. **事件驱动模型**：
   - Redis 使用事件驱动模型来处理客户端请求。
   - 服务器维护一个事件循环（event loop），监听连接事件、读事件和写事件。
   - 当有新的客户端连接时，服务器会创建一个新的客户端对象，并将其添加到事件循环中。

# ZSET底层原理

`zset`（sorted set，有序集合）是 Redis 中的一种数据结构，用于存储一系列不重复的字符串元素，每个元素都关联一个分数（score），可以根据分数对元素进行排序。

以下是 `zset` 的底层原理：

### 数据结构

`zset` 底层主要使用两种数据结构：

1. **跳跃表（Skip List）**：用于按分数快速访问元素，实现排序功能。
2. **哈希表（Hash Table）**：用于存储元素到分数的映射，实现元素与分数的快速查找。

### 跳跃表

跳跃表是一种概率数据结构，它在有序链表的基础上增加了多级索引，以提高搜索效率。跳跃表的每一层都是前一层的子集。

- **头节点（header）**：跳跃表的头节点不存储任何元素，它的多级指针指向表中其它的节点。
- **尾节点（tail）**：跳跃表的尾节点表示跳跃表的末尾。
- **节点（node）**：每个节点包含元素值、分数、后退指针（用于从尾部向前遍历）以及多个层级的指针。

跳跃表通过随机层数的方式，在保持对数时间复杂度的同时，减少了索引所需的额外空间。

### 哈希表

哈希表存储元素到分数的映射，使得在 O(1) 时间复杂度内查找元素的分数。同时，哈希表也存储了元素到跳跃表节点的指针，以便在修改分数时可以快速更新跳跃表。

### 操作原理

- **添加元素**：首先在哈希表中查找元素是否存在，如果不存在，则创建一个新的跳跃表节点，并随机选择层数。然后在跳跃表中找到合适的位置插入新节点，并更新哈希表。
- **删除元素**：在哈希表中查找元素，如果存在，则在跳跃表中找到对应的节点并删除，同时更新跳跃表的前后指针，最后从哈希表中删除该元素。
- **查找元素**：通过跳跃表按分数查找元素，时间复杂度为 O(log N)。
- **范围查询**：跳跃表支持按分数范围查询元素，通过头节点的多级指针可以快速定位到起始位置，然后顺序遍历。
- **更新分数**：如果元素的分数更新，需要先在跳跃表中找到该元素，然后删除旧的节点，并按照新的分数重新插入。

### 总结

`zset` 的底层原理结合了跳跃表和哈希表的优点，跳跃表提供了有序性，哈希表提供了快速的查找能力。这种组合使得 `zset` 在进行有序集合操作时既保持了高效性也保持了灵活性。