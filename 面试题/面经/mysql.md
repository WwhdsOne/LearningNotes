# MVCC

MVCC（多版本并发控制）的底层实现依赖于数据库的具体存储引擎和其内部机制。以下是一些常见的底层组件和技术，它们在实现MVCC时可能会被用到：

1. **时间戳或事务ID**：
   - **系统版本号（System Version Number）**：每个事务在开始时都会被分配一个唯一的时间戳或版本号。这个编号用于追踪事务的顺序和确定数据版本的可见性。
   - **事务ID**：与时间戳类似，事务ID用于标识事务并确定数据版本的可见性。
2. **版本链（Version Chain）**：
   - 当数据记录被修改时，不是直接覆盖原记录，而是生成一个新的记录版本，并将它与原记录通过指针链接起来，形成一个版本链。每个版本包含事务ID、指向下一个版本的指针以及数据本身。
3. **undo日志：**
   - 当记录被更新或删除时，数据库会记录相应的undo日志，这些日志包含了如何恢复到旧版本所需的信息。在事务回滚或系统需要提供旧版本数据时，这些日志被用来撤销更改。
4. **可见性规则**：
   - 数据库通过一定的规则来判断哪些版本的数据对当前事务是可见的。这通常涉及到比较当前事务的ID与数据版本的事务ID，以及事务的隔离级别。
5. **并发控制数据结构**：
   - 如**锁表**、**事务表**、**活动事务列表**等，这些数据结构帮助数据库管理并发事务的状态和它们对数据的影响。
6. **垃圾回收（Garbage Collection）**：
   - 为了避免无限增长的数据版本，数据库会定期执行垃圾回收，清理不再需要的旧版本数据。这通常涉及到对版本链的遍历和判断哪些版本可以被删除。
   下面是一个简化的例子，描述了MVCC的底层实现：
```
记录结构:
+-------------------+
| 事务ID | 数据 | 指向下一个版本的指针 |
+-------------------+
版本链:
记录A: [事务100] --> [事务95] --> [事务90] ...
事务处理:
1. 当事务开始时，它被分配一个唯一的事务ID。
2. 读取操作根据事务ID和可见性规则遍历版本链，找到合适的版本。
3. 写入操作创建一个新版本，并将其插入到版本链的头部。
4. 回滚或提交操作更新事务的状态，并可能触发垃圾回收。
```
不同的数据库系统可能会有不同的实现细节，但上述概念是大多数MVCC实现的基础。例如，PostgreSQL使用的是多版本时间戳，而InnoDB存储引擎则使用系统版本号。

# UUID和主键ID同时使用

在分布式系统中，使用自增整数（例如 `SERIAL` 或 `AUTO_INCREMENT`）作为主键可能会遇到唯一性问题。这是因为自增整数是在单个数据库实例中生成的，而在分布式环境中，多个数据库实例可能会生成相同的自增整数，从而导致唯一性冲突。

#### 1. 自增整数的唯一性问题

在分库分表的情况下，每个分片（Shard）或表可能会独立生成自增整数主键。这会导致在不同分片或表之间生成相同的自增整数，从而引发唯一性冲突。

#### 2. 数据分布不均匀

分库分表可能导致数据分布不均匀，某些分片或表的数据量过大，而其他分片或表的数据量较小。这会影响系统的性能和扩展性。

#### 3. 事务一致性

在分布式系统中，跨分片或表的事务一致性变得更加复杂。确保数据的一致性和完整性需要额外的机制和策略。