# 1. ConcurrentHashMap 和 Hashtable 的区别

- **ConcurrentHashMap**:
  - 线程安全，支持高并发。
  - 使用分段锁（Segment）机制，允许多个线程同时访问不同的段。
  - 性能较高，适用于高并发场景。
- **Hashtable**:
  - 线程安全，但使用全局锁，性能较低。
  - 不支持高并发，适用于低并发场景。

# 2. 扩容机制，链表怎么扩容至红黑树

- **扩容机制**:
  - 当 HashMap 中的元素数量超过阈值（容量 * 负载因子）时，会触发扩容。
  - 新表的大小是旧表的两倍。
- **链表扩容至红黑树**:
  - 当链表长度超过 8 且数组长度超过 64 时，链表会转换为红黑树。
  - 红黑树的插入、删除和查找操作的时间复杂度为 O(log n)，提高了性能。

# 3. Java IO 类型

- **BIO (Blocking I/O)**:
  - 阻塞式 I/O，线程在读写数据时会被阻塞。
  - 适用于连接数较少且稳定的场景。
- **NIO (Non-blocking I/O)**:
  - 非阻塞式 I/O，使用 Channel 和 Buffer 进行数据传输。
  - 适用于高并发、连接数较多的场景。
- **AIO (Asynchronous I/O)**:
  - 异步 I/O，基于事件和回调机制。
  - 适用于高性能、高并发的场景。

# 4. NIO 和 BIO

- **NIO**:
  - 非阻塞式 I/O，使用 Channel 和 Buffer。
  - 适用于高并发、连接数较多的场景。
- **BIO**:
  - 阻塞式 I/O，线程在读写数据时会被阻塞。
  - 适用于连接数较少且稳定的场景。

# 5. HashMap 为什么新表是旧表的两倍呢

- **原因**:
  - 扩容为旧表的两倍可以减少哈希冲突，提高查询效率。
  - 扩容后，元素的分布更加均匀，减少了链表长度，提高了性能。

# 6. IO 多路复用

- **底层实现**:
  - 通过操作系统提供的 select、poll、epoll 等机制实现。
  - 允许单个线程监视多个文件描述符，当某个文件描述符就绪时，通知应用程序进行处理。

# 7. ThreadLocal

- **内存泄漏问题**:
  - ThreadLocal 可能导致内存泄漏，因为每个线程都有一个 ThreadLocalMap，存储 ThreadLocal 对象和对应的值。
  - 如果线程长时间存活，ThreadLocalMap 中的 Entry 可能不会被回收，导致内存泄漏。
- **解决方法**:
  - 使用完 ThreadLocal 后，调用 `remove()` 方法清除数据。
- **应用场景**:
  - 线程隔离，如数据库连接、Session 管理等。

# 8. JDK 实现的锁的种类

- **ReentrantLock**:
  - 可重入锁，支持公平锁和非公平锁。
- **ReentrantReadWriteLock**:
  - 读写锁，允许多个线程同时读，但只允许一个线程写。
- **StampedLock**:
  - 乐观读锁，适用于读多写少的场景。

# 9. JDK 自带的锁和 JVM 的锁的区别

- **JDK 自带的锁**:
  - 通过 Java 代码实现，如 ReentrantLock、ReentrantReadWriteLock 等。
- **JVM 的锁**:
  - 通过 JVM 实现，如 synchronized 关键字。

# 10. AQS (AbstractQueuedSynchronizer)

- **原理**:
  - 基于 FIFO 队列实现，维护一个状态变量和一个等待队列。
  - 线程通过 CAS 操作尝试获取锁，如果失败则进入等待队列。
- **实现类**:
  - ReentrantLock、Semaphore、CountDownLatch 等。

# 11. 用过的线程池

- **ThreadPoolExecutor**:
  - 核心线程数、最大线程数、空闲线程存活时间、任务队列、拒绝策略等参数。
- **运行过程**:
  - 提交任务时，先尝试使用核心线程执行，如果核心线程数已满，则将任务放入任务队列。
  - 如果任务队列已满，则创建新的线程执行任务，直到达到最大线程数。
  - 如果达到最大线程数且任务队列已满，则执行拒绝策略。

# 12. Java 代理的实现方式

- **JDK 动态代理**:
  - 基于接口的代理，通过 `Proxy` 类和 `InvocationHandler` 接口实现。
- **CGLIB 动态代理**:
  - 基于类的代理，通过继承目标类实现。

# 13. MySQL 事务隔离级别

- **读未提交 (Read Uncommitted)**:
  - 可能出现脏读、不可重复读、幻读。
- **读已提交 (Read Committed)**:
  - 可能出现不可重复读、幻读。
- **可重复读 (Repeatable Read)**:
  - 可能出现幻读。
- **串行化 (Serializable)**:
  - 不会出现并发问题，但性能较低。

# 14. 各个级别有什么问题

- **读未提交**:
  - 脏读：读取到未提交的数据。
  - 不可重复读：同一事务中，多次读取同一数据结果不同。
  - 幻读：同一事务中，多次读取同一范围的数据结果不同。
- **读已提交**:
  - 不可重复读：同一事务中，多次读取同一数据结果不同。
  - 幻读：同一事务中，多次读取同一范围的数据结果不同。
- **可重复读**:
  - 幻读：同一事务中，多次读取同一范围的数据结果不同。
- **串行化**:
  - 不会出现并发问题，但性能较低。

# 15. 详细介绍一下 InnoDB

- **特点**:
  - 支持事务，提供 ACID 特性。
  - 使用行级锁，支持高并发。
  - 使用 B+ 树作为索引结构。
- **B+ 树的结构**:
  - 每个节点可以存储多个键值对。
  - 叶子节点存储数据，非叶子节点存储索引。
- **B+ 树为什么快**:
  - 查询效率高，时间复杂度为 O(log n)。
  - 范围查询效率高，叶子节点之间有指针连接。

# 16. 设计数据库索引的原则

- **原则**:
  - 选择合适的列作为索引，如经常查询的列、主键、外键等。
  - 避免在频繁更新的列上创建索引，减少索引维护开销。
  - 使用组合索引时，注意索引列的顺序。

# 17. 索引怎么匹配

- **原理**:
  - 通过 B+ 树结构快速定位数据。
  - 索引列的值作为 B+ 树的键，通过二分查找快速定位数据。

# 18. 索引失效的情况

- **情况**:
  - 使用函数或表达式操作索引列。
  - 使用 `!=`、`<>`、`NOT IN` 等操作符。
  - 使用 `LIKE` 查询时，通配符在开头。

# 19. 500w 条的订单数据，查询列表，分页查询怎么写 SQL

- **SQL 示例**:

  sql

  复制

  ```
  SELECT * FROM orders
  ORDER BY order_date DESC
  LIMIT 10 OFFSET 0;
  ```

- **解释**:

  - `LIMIT 10 OFFSET 0` 表示查询第 1 页，每页 10 条数据。
  - `ORDER BY order_date DESC` 按订单日期降序排列。

# 20. Redis 数据结构

- **String**:
  - 底层使用 SDS (Simple Dynamic String) 实现。
- **List**:
  - 底层使用双向链表或压缩列表实现。
- **Set**:
  - 底层使用哈希表或整数集合实现。
- **Hash**:
  - 底层使用哈希表或压缩列表实现。
- **Sorted Set**:
  - 底层使用跳表或压缩列表实现。

# 21. String 的底层 SDS 说一下 SDS 和 String 的区别，优点

- **SDS (Simple Dynamic String)**:
  - 动态字符串，支持自动扩容。
  - 存储字符串长度，减少字符串长度计算的开销。
- **区别**:
  - SDS 支持动态扩容，String 不支持。
  - SDS 存储字符串长度，String 需要每次计算。
- **优点**:
  - 减少字符串长度计算的开销。
  - 支持动态扩容，避免频繁的内存分配。

# 22. 缓存击穿

- **问题**:
  - 高并发场景下，某个热点数据失效，导致大量请求直接访问数据库。
- **解决方法**:
  - 使用互斥锁，保证只有一个线程去加载数据。
  - 设置热点数据永不过期。

# 23. 布隆过滤器

- **原理**:
  - 使用多个哈希函数将元素映射到一个位数组中。
  - 判断元素是否存在时，通过多个哈希函数计算位数组中的位置，如果所有位置都为 1，则元素可能存在。
- **优点**:
  - 空间效率高，时间复杂度低。
- **缺点**:
  - 存在一定的误判率。

# 24. Redisson 看门狗机制

- **原理**:
  - 自动续期锁的过期时间，防止锁过期导致并发问题。
  - 通过定时任务定期检查锁的过期时间，并自动续期。

# 25. 页面长期未响应如何解决

- **解决方法**:
  - 优化代码，减少阻塞操作。
  - 使用异步处理，避免阻塞主线程。
  - 使用线程池，提高并发处理能力。

# 26. 如果总是出现 Full GC 是什么情况

- **情况**:
  - 内存泄漏，导致老年代空间不足。
  - 大对象直接进入老年代，导致老年代空间不足。
  - 频繁的 Minor GC，导致老年代空间不足。

# 27. 说一下 synchronized 底层实现

- **底层实现**:
  - 通过 JVM 实现，使用 Monitor 机制。
  - 进入同步代码块时，线程会尝试获取 Monitor 锁，如果获取成功，则进入同步代码块。
  - 如果获取失败，则线程进入等待队列，等待其他线程释放锁。

# 28. synchronized 和 ReentrantLock 区别

- **synchronized**:
  - JVM 内置锁，使用 Monitor 机制。
  - 自动释放锁，不需要手动释放。
- **ReentrantLock**:
  - JDK 提供的锁，使用 AQS 机制。
  - 需要手动加锁和释放锁。
  - 支持公平锁和非公平锁。

# 29. Redis 单线程模型

- **原理**:
  - 使用单线程处理客户端请求，避免多线程竞争。
  - 通过事件驱动模型，使用 epoll/kqueue 实现高并发。
- **优点**:
  - 避免多线程竞争，简化代码逻辑。
  - 提高性能，减少上下文切换开销。