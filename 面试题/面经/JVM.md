# ZGC VS G1

Z Garbage Collector（ZGC）相对于 G1 Garbage Collector（G1GC）减少了并发量，这主要是由于它们的设计目标和实现方式的不同。以下是一些关键原因：

### 1. **设计目标**

- **ZGC 的设计目标**：ZGC 的主要目标是实现极低的暂停时间（通常在 10 毫秒以下），即使在处理非常大的堆内存（TB 级别）时也能保持这一目标。为了实现这一目标，ZGC 采用了并发标记和并发重定位的策略，尽量减少应用程序的暂停时间。
- **G1GC 的设计目标**：G1GC 的设计目标是平衡吞吐量和暂停时间，它采用了分代收集策略，将堆内存分为多个区域（Region），并根据对象的生命周期进行不同的收集策略。G1GC 的暂停时间通常在几十毫秒到几百毫秒之间。

### 2. **并发标记和重定位**

- **ZGC 的并发标记和重定位**：ZGC 在整个垃圾收集周期中都尽量保持并发操作，包括并发标记和并发重定位。这使得 ZGC 能够在不暂停应用程序的情况下完成大部分垃圾收集工作，从而减少暂停时间。
- **G1GC 的并发标记**：G1GC 在标记阶段也采用了并发标记，但在重定位阶段通常需要暂停应用程序（STW，Stop-The-World）。G1GC 的并发量相对较低，因为它需要在某些阶段暂停应用程序以确保垃圾收集的正确性。

### 3. **颜色指针和负载屏障**

- **ZGC 的颜色指针和负载屏障**：ZGC 使用颜色指针来跟踪对象的状态，并通过负载屏障来确保并发操作的正确性。这些技术使得 ZGC 能够在不暂停应用程序的情况下进行并发标记和重定位。
- **G1GC 的并发标记和混合收集**：G1GC 使用并发标记和混合收集策略，但在某些阶段（如重定位阶段）需要暂停应用程序。G1GC 的并发量相对较低，因为它需要在某些阶段暂停应用程序以确保垃圾收集的正确性。

### 4. **不分代 vs 分代**

- **ZGC 的不分代策略**：ZGC 不分代，它在整个堆内存中进行并发收集。这种设计简化了垃圾收集的复杂性，并减少了暂停时间。
- **G1GC 的分代策略**：G1GC 采用分代收集策略，将堆内存分为年轻代和老年代，并根据对象的生命周期进行不同的收集策略。这种分代策略增加了垃圾收集的复杂性，并可能导致更多的暂停时间。

### 总结

ZGC 相对于 G1GC 减少了并发量，主要是因为 ZGC 的设计目标是在处理大内存时保持极低的暂停时间。通过采用并发标记和并发重定位、颜色指针和负载屏障等技术，ZGC 能够在不暂停应用程序的情况下完成大部分垃圾收集工作，从而减少暂停时间。而 G1GC 虽然也采用了并发标记，但在某些阶段需要暂停应用程序，因此并发量相对较低。

# G1 VS CMS

### 暂停时间控制

- **G1** 提供了更精细的暂停时间控制，用户可以指定最大暂停时间目标（`-XX:MaxGCPauseMillis`），G1 会尽量满足这个要求。通过调整堆内存的区域大小和回收策略，G1 可以实现较为可控的暂停时间。
- **CMS** 尽管也尽量减少停顿时间，但其暂停时间不可预测，尤其在老年代需要回收时。CMS 在遇到 Full GC 时会有长时间的暂停，通常超过几秒。

### 回收过程

- **G1** 将堆分为多个固定大小的区域（Region），每个区域可以是年轻代或老年代的一部分，回收时会优先选择回收垃圾最多的区域（即“垃圾优先”）。
   - G1 在并行回收年轻代和并发回收老年代时，会根据目标暂停时间来选择回收区域的优先级，尽量减少每次回收的停顿时间。
   
- **CMS** 使用标记-清除算法进行回收。首先标记所有的垃圾对象，然后清理这些垃圾对象。CMS 的回收过程有并发标记（CM）和并发清理（SC）阶段，应用线程在这些阶段可以继续运行。但由于缺乏像 G1 那样的区域划分和暂停时间的精细控制，CMS 在高负载下会出现长时间的停顿。

# 堆内存和栈内存

### 堆内存（Heap Memory）

堆内存是 Java 虚拟机（JVM）中用于存储对象实例的内存区域。所有通过 `new` 关键字创建的对象都存储在堆内存中。堆内存的特点如下：

1. **动态分配**：
   - 堆内存是动态分配的，对象的大小在运行时确定。
   - 对象的创建和销毁由垃圾回收器（Garbage Collector）管理。
2. **共享内存**：
   - 堆内存是所有线程共享的内存区域。
   - 任何线程都可以访问堆内存中的对象。
3. **存储内容**：
   - 堆内存用于存储对象实例、数组和字符串池（String Pool）。
   - 对象的实例变量也存储在堆内存中。
4. **生命周期**：
   - 对象的生命周期由垃圾回收器管理。
   - 当对象不再被引用时，垃圾回收器会自动回收其占用的内存。
5. **内存管理**：
   - 堆内存的管理由垃圾回收器负责，垃圾回收器会定期扫描堆内存，回收不再使用的对象。
   - 堆内存的大小可以通过 JVM 参数进行配置。

### 栈内存（Stack Memory）

栈内存是 Java 虚拟机中用于存储局部变量、方法调用和控制流的内存区域。每个线程在运行时都有一个独立的栈内存。栈内存的特点如下：

1. **静态分配**：
   - 栈内存是静态分配的，内存大小在编译时确定。
   - 栈内存的大小通常较小，且固定不变。
2. **线程私有**：
   - 栈内存是线程私有的，每个线程都有自己的栈内存。
   - 不同线程之间的栈内存是相互独立的。
3. **存储内容**：
   - 栈内存用于存储局部变量、方法参数、返回值和控制流信息（如方法调用栈帧）。
   - 基本数据类型（如 `int`、`float`）和对象引用（如 `String` 引用）存储在栈内存中。
4. **生命周期**：
   - 栈内存的生命周期与方法调用相关。
   - 当方法调用结束时，栈内存中的局部变量和方法参数会被自动释放。
5. **内存管理**：
   - 栈内存的管理由 JVM 自动完成，不需要垃圾回收器介入。
   - 栈内存的大小可以通过 JVM 参数进行配置。