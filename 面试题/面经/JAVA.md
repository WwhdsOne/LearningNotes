# ConcurrentHashMap 和 Hashtable 的区别

- **ConcurrentHashMap**:
  - 线程安全，支持高并发。
  - 使用分段锁（Segment）机制，允许多个线程同时访问不同的段。
  - 性能较高，适用于高并发场景。
- **Hashtable**:
  - 线程安全，但使用全局锁，性能较低。
  - 不支持高并发，适用于低并发场景。

# 扩容机制，链表怎么扩容至红黑树

- **扩容机制**:
  - 当 HashMap 中的元素数量超过阈值（容量 * 负载因子）时，会触发扩容。
  - 新表的大小是旧表的两倍。
- **链表扩容至红黑树**:
  - 当链表长度超过 8 且数组长度超过 64 时，链表会转换为红黑树。
  - 红黑树的插入、删除和查找操作的时间复杂度为 O(log n)，提高了性能。

# Java IO 类型

- **BIO (Blocking I/O)**:
  - 阻塞式 I/O，线程在读写数据时会被阻塞。
  - 适用于连接数较少且稳定的场景。
- **NIO (Non-blocking I/O)**:
  - 非阻塞式 I/O，使用 Channel 和 Buffer 进行数据传输。
  - 适用于高并发、连接数较多的场景。
- **AIO (Asynchronous I/O)**:
  - 异步 I/O，基于事件和回调机制。
  - 适用于高性能、高并发的场景。

# HashMap 为什么新表是旧表的两倍呢

- **原因**:
  - 扩容为旧表的两倍可以减少哈希冲突，提高查询效率。
  - 扩容后，元素的分布更加均匀，减少了链表长度，提高了性能。
  - 因为与散列公式`index = hash(key) & (new_length - 1)`进行散列,如果是2的倍数-1,可以获得类似`1111`的数，进行散列可以使用位运算，更快。

# JDK 实现的锁的种类

- **ReentrantLock**:
  - 可重入锁，支持公平锁和非公平锁。
- **ReentrantReadWriteLock**:
  - 读写锁，允许多个线程同时读，但只允许一个线程写。
- **StampedLock**:
  - 乐观读锁，适用于读多写少的场景。

# NIO 和 BIO

- **NIO**:
  - 非阻塞式 I/O，使用 Channel 和 Buffer。
  - 适用于高并发、连接数较多的场景。
- **BIO**:
  - 阻塞式 I/O，线程在读写数据时会被阻塞。
  - 适用于连接数较少且稳定的场景。

# ThreadLocal

- **内存泄漏问题**:

  - ThreadLocal 可能导致内存泄漏，因为每个线程都有一个 ThreadLocalMap，存储 ThreadLocal 对象和对应的值。

  - 如果线程长时间存活，ThreadLocalMap 中的 Entry 可能不会被回收，导致内存泄漏。

  - **长生命周期线程**：当线程存活时间较长时（例如线程池中的线程），如果开发者没有手动调用 `remove()` 清除 `ThreadLocal`，这些 `ThreadLocal` 变量可能会一直保存在 `ThreadLocalMap` 中，即使不再需要。

    **键被回收**：由于 `ThreadLocal` 键是弱引用，如果 `ThreadLocal` 对象被垃圾回收，键将被清除，但值是强引用，值仍然存在，导致内存泄漏，因为垃圾回收器无法回收这些值。

- **解决方法**:

  - 使用完 ThreadLocal 后，调用 `remove()` 方法清除数据。

- **应用场景**:

  - 线程隔离，如数据库连接、Session 管理等。

