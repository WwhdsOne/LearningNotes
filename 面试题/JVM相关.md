# 1. 关于运行时常量池，下列哪个说法是正确的

A 运行时常量池大小受栈区大小的影响

B 运行时常量池大小受方法区大小的影响

C 存放了编译时期生成的各种字面量

D 存放编译时期生成的符号引用

正确答案：BCD

> 为了避免歧义，以下提及的JVM，是Hotspot
>
> 方法区是什么？
> 方法区是广义上的概念，是一个定义、标准，可以理解为Java中的接口，在Jdk6、7方法区的实现叫永久代；Jdk8之后方法区的实现叫元空间，并从JVM内存中移除，放到了直接内存中；
> 方法区是被所有方法线程共享的一块内存区域.
>
> 运行时常量池是什么？
> 运行时常量池是每一个类或接口的常量池的运行时表示形式.
>
> 具体体现就是在Java编译后生成的.class文件中，会有class常量池，也就是静态的运行时常量池；  
>
> 运行时常量池存放的位置？ 
>
> 运行时常量池一直是方法区的一部分，在不同版本的JDK中，由于方法区位置的变化，运行时常量池所处的位置也不一样.JDK1.7及之前方法区位于永久代.由于一些原因在JDK1.8之后彻底祛除了永久代,用元空间代替。 
>
> 运行时常量池存放什么？
> 存放编译期生成的各种字面量和符号引用；（字面量和符号引用不懂的同学请自行查阅）
> 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。 此时不再是常量池中的符号地址了，这里换为真实地址。
>
> 运行时常量池与字符串常量池？（可能有同学把他俩搞混）
> 字符串常量池：在JVM中，为了减少相同的字符串的重复创建，为了达到节省内存的目的。会单独开辟一块内存，用于保存字符串常量，这个内存区域被叫做字符串常量池.
>
> 字符串常量池位置？ 
>
> JDK1.6时字符串常量池，被存放在方法区中（永久代），而到了JDK1.7，因为永久代垃圾回收频率低；而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足，就被移动到了堆内存中。

# 2. 以下哪个区域不属于新生代？

正确答案：C

A eden区

B from区

C 元数据区

D to区

> （1）Eden区，from区，to区：三个区的内存比例可以通过参数【–XX:SurvivorRatio=数字】配置，默认该值为8，即Eden:from:to = 8:1:1 
>
> （2）大部分对象创建都是在Eden的（除了个别大对象外，大对象内存可以设置参数【-XX:PretenureSizeThreshold=字节数】配置，超过配置内存的大对象直接进入老年代），from和to不是固定的（可以互换身份，Survivor区），初始化的时候其中一个是空的。
>
> （3）新生代的 Minor GC 中，一个Survivor区中数据复制进去，另个是空的，下一次GC的时候，有数据的是from Survivor，没数据的to Survivor，GC的时候，from区和Eden区的数据都复制到to中。这样from和to就互换身份，一直这么循环处理。
>
> （4）第（3）步中复制一次，所有对象年龄加1，当任意一个对象复制到一定次数（默认15次，可以配置【-XX:MaxTenuringThreshold=数字】参数进行修改）的时候，就被复制到了老年代 
>
> （5）提到老年代，再补充一下，新生代 ( Young )、老年代 ( Old )内存比例为=1:2，新生代加老年代就是java堆内存了
>
> ![4AC5BFBDFC533AA394D4433D2375A422](https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/4AC5BFBDFC533AA394D4433D2375A422.png)

# 3. JVM内存不包含如下哪个部分(待学习)

正确答案：D

A Stacks
B PC寄存器
C Heap
D Heap Frame

> ![272084FEBFF2E659FA20DF7ACF52DD13](https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/272084FEBFF2E659FA20DF7ACF52DD13.png)

# 4. 以下描述错误的一项是（ JVM内存 ）？

正确答案: C  你的答案: A (错误)

A 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行  到了第几行，是线程隔离的
B 原则上讲，所有的对象都是在堆区上分配内存，是线程之间共享的
C 方法区用于存储JVM加载的类信息、常量、静态变量，即使编译器编译后的代码等数据，是线程隔离的
D Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的

> <img src="https://wwhds-markdown-image.oss-cn-beijing.aliyuncs.com/5032673_1539139922699_59B2900AA03CB2182A51CDB520B535B6.png" alt="5032673_1539139922699_59B2900AA03CB2182A51CDB520B535B6" style="zoom: 50%;" />
>
> JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)
>
> - 栈区:
>
> 1. **每个线程包含一个栈区**，栈中只保存方法中（不包括对象的成员变量）的**基础数据类型和自定义对象的引用(不是对象)**，对象都存放在堆区中
> 2. 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
> 3. 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
>
> - 堆区:
>
> 1. 存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。
> 2. **jvm只有一个堆区(heap)被所有线程共享**，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的**对象实例和数组**都在堆中分配。
>
> - 方法区:
>
> 1. 又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。